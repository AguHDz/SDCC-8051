                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.6.0 #9615 (MINGW32)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _moveclock
                                     13 	.globl _display
                                     14 	.globl _resetfn
                                     15 	.globl _increase
                                     16 	.globl _setfn
                                     17 	.globl _delay
                                     18 	.globl _CY
                                     19 	.globl _AC
                                     20 	.globl _F0
                                     21 	.globl _RS1
                                     22 	.globl _RS0
                                     23 	.globl _OV
                                     24 	.globl _F1
                                     25 	.globl _P
                                     26 	.globl _PS
                                     27 	.globl _PT1
                                     28 	.globl _PX1
                                     29 	.globl _PT0
                                     30 	.globl _PX0
                                     31 	.globl _RD
                                     32 	.globl _WR
                                     33 	.globl _T1
                                     34 	.globl _T0
                                     35 	.globl _INT1
                                     36 	.globl _INT0
                                     37 	.globl _TXD
                                     38 	.globl _RXD
                                     39 	.globl _P3_7
                                     40 	.globl _P3_6
                                     41 	.globl _P3_5
                                     42 	.globl _P3_4
                                     43 	.globl _P3_3
                                     44 	.globl _P3_2
                                     45 	.globl _P3_1
                                     46 	.globl _P3_0
                                     47 	.globl _EA
                                     48 	.globl _ES
                                     49 	.globl _ET1
                                     50 	.globl _EX1
                                     51 	.globl _ET0
                                     52 	.globl _EX0
                                     53 	.globl _P2_7
                                     54 	.globl _P2_6
                                     55 	.globl _P2_5
                                     56 	.globl _P2_4
                                     57 	.globl _P2_3
                                     58 	.globl _P2_2
                                     59 	.globl _P2_1
                                     60 	.globl _P2_0
                                     61 	.globl _SM0
                                     62 	.globl _SM1
                                     63 	.globl _SM2
                                     64 	.globl _REN
                                     65 	.globl _TB8
                                     66 	.globl _RB8
                                     67 	.globl _TI
                                     68 	.globl _RI
                                     69 	.globl _P1_7
                                     70 	.globl _P1_6
                                     71 	.globl _P1_5
                                     72 	.globl _P1_4
                                     73 	.globl _P1_3
                                     74 	.globl _P1_2
                                     75 	.globl _P1_1
                                     76 	.globl _P1_0
                                     77 	.globl _TF1
                                     78 	.globl _TR1
                                     79 	.globl _TF0
                                     80 	.globl _TR0
                                     81 	.globl _IE1
                                     82 	.globl _IT1
                                     83 	.globl _IE0
                                     84 	.globl _IT0
                                     85 	.globl _P0_7
                                     86 	.globl _P0_6
                                     87 	.globl _P0_5
                                     88 	.globl _P0_4
                                     89 	.globl _P0_3
                                     90 	.globl _P0_2
                                     91 	.globl _P0_1
                                     92 	.globl _P0_0
                                     93 	.globl _B
                                     94 	.globl _ACC
                                     95 	.globl _PSW
                                     96 	.globl _IP
                                     97 	.globl _P3
                                     98 	.globl _IE
                                     99 	.globl _P2
                                    100 	.globl _SBUF
                                    101 	.globl _SCON
                                    102 	.globl _P1
                                    103 	.globl _TH1
                                    104 	.globl _TH0
                                    105 	.globl _TL1
                                    106 	.globl _TL0
                                    107 	.globl _TMOD
                                    108 	.globl _TCON
                                    109 	.globl _PCON
                                    110 	.globl _DPH
                                    111 	.globl _DPL
                                    112 	.globl _SP
                                    113 	.globl _P0
                                    114 	.globl _dig_val
                                    115 	.globl _mode
                                    116 	.globl _loop
                                    117 	.globl _keepsec1
                                    118 	.globl _keepsec2
                                    119 	.globl _keepmin1
                                    120 	.globl _keepmin2
                                    121 	.globl _alarmsec1
                                    122 	.globl _alarmsec2
                                    123 	.globl _alarmmin1
                                    124 	.globl _alarmmin2
                                    125 	.globl _secalarm1
                                    126 	.globl _secalarm2
                                    127 	.globl _minalarm1
                                    128 	.globl _minalarm2
                                    129 	.globl _sec1
                                    130 	.globl _sec2
                                    131 	.globl _min1
                                    132 	.globl _min2
                                    133 	.globl _dig_disp
                                    134 	.globl _begin
                                    135 	.globl _recnt_incr_seg
                                    136 	.globl _ret_seg_to_incre
                                    137 	.globl _sel_seg_to_incr
                                    138 ;--------------------------------------------------------
                                    139 ; special function registers
                                    140 ;--------------------------------------------------------
                                    141 	.area RSEG    (ABS,DATA)
      000000                        142 	.org 0x0000
                           000080   143 _P0	=	0x0080
                           000081   144 _SP	=	0x0081
                           000082   145 _DPL	=	0x0082
                           000083   146 _DPH	=	0x0083
                           000087   147 _PCON	=	0x0087
                           000088   148 _TCON	=	0x0088
                           000089   149 _TMOD	=	0x0089
                           00008A   150 _TL0	=	0x008a
                           00008B   151 _TL1	=	0x008b
                           00008C   152 _TH0	=	0x008c
                           00008D   153 _TH1	=	0x008d
                           000090   154 _P1	=	0x0090
                           000098   155 _SCON	=	0x0098
                           000099   156 _SBUF	=	0x0099
                           0000A0   157 _P2	=	0x00a0
                           0000A8   158 _IE	=	0x00a8
                           0000B0   159 _P3	=	0x00b0
                           0000B8   160 _IP	=	0x00b8
                           0000D0   161 _PSW	=	0x00d0
                           0000E0   162 _ACC	=	0x00e0
                           0000F0   163 _B	=	0x00f0
                                    164 ;--------------------------------------------------------
                                    165 ; special function bits
                                    166 ;--------------------------------------------------------
                                    167 	.area RSEG    (ABS,DATA)
      000000                        168 	.org 0x0000
                           000080   169 _P0_0	=	0x0080
                           000081   170 _P0_1	=	0x0081
                           000082   171 _P0_2	=	0x0082
                           000083   172 _P0_3	=	0x0083
                           000084   173 _P0_4	=	0x0084
                           000085   174 _P0_5	=	0x0085
                           000086   175 _P0_6	=	0x0086
                           000087   176 _P0_7	=	0x0087
                           000088   177 _IT0	=	0x0088
                           000089   178 _IE0	=	0x0089
                           00008A   179 _IT1	=	0x008a
                           00008B   180 _IE1	=	0x008b
                           00008C   181 _TR0	=	0x008c
                           00008D   182 _TF0	=	0x008d
                           00008E   183 _TR1	=	0x008e
                           00008F   184 _TF1	=	0x008f
                           000090   185 _P1_0	=	0x0090
                           000091   186 _P1_1	=	0x0091
                           000092   187 _P1_2	=	0x0092
                           000093   188 _P1_3	=	0x0093
                           000094   189 _P1_4	=	0x0094
                           000095   190 _P1_5	=	0x0095
                           000096   191 _P1_6	=	0x0096
                           000097   192 _P1_7	=	0x0097
                           000098   193 _RI	=	0x0098
                           000099   194 _TI	=	0x0099
                           00009A   195 _RB8	=	0x009a
                           00009B   196 _TB8	=	0x009b
                           00009C   197 _REN	=	0x009c
                           00009D   198 _SM2	=	0x009d
                           00009E   199 _SM1	=	0x009e
                           00009F   200 _SM0	=	0x009f
                           0000A0   201 _P2_0	=	0x00a0
                           0000A1   202 _P2_1	=	0x00a1
                           0000A2   203 _P2_2	=	0x00a2
                           0000A3   204 _P2_3	=	0x00a3
                           0000A4   205 _P2_4	=	0x00a4
                           0000A5   206 _P2_5	=	0x00a5
                           0000A6   207 _P2_6	=	0x00a6
                           0000A7   208 _P2_7	=	0x00a7
                           0000A8   209 _EX0	=	0x00a8
                           0000A9   210 _ET0	=	0x00a9
                           0000AA   211 _EX1	=	0x00aa
                           0000AB   212 _ET1	=	0x00ab
                           0000AC   213 _ES	=	0x00ac
                           0000AF   214 _EA	=	0x00af
                           0000B0   215 _P3_0	=	0x00b0
                           0000B1   216 _P3_1	=	0x00b1
                           0000B2   217 _P3_2	=	0x00b2
                           0000B3   218 _P3_3	=	0x00b3
                           0000B4   219 _P3_4	=	0x00b4
                           0000B5   220 _P3_5	=	0x00b5
                           0000B6   221 _P3_6	=	0x00b6
                           0000B7   222 _P3_7	=	0x00b7
                           0000B0   223 _RXD	=	0x00b0
                           0000B1   224 _TXD	=	0x00b1
                           0000B2   225 _INT0	=	0x00b2
                           0000B3   226 _INT1	=	0x00b3
                           0000B4   227 _T0	=	0x00b4
                           0000B5   228 _T1	=	0x00b5
                           0000B6   229 _WR	=	0x00b6
                           0000B7   230 _RD	=	0x00b7
                           0000B8   231 _PX0	=	0x00b8
                           0000B9   232 _PT0	=	0x00b9
                           0000BA   233 _PX1	=	0x00ba
                           0000BB   234 _PT1	=	0x00bb
                           0000BC   235 _PS	=	0x00bc
                           0000D0   236 _P	=	0x00d0
                           0000D1   237 _F1	=	0x00d1
                           0000D2   238 _OV	=	0x00d2
                           0000D3   239 _RS0	=	0x00d3
                           0000D4   240 _RS1	=	0x00d4
                           0000D5   241 _F0	=	0x00d5
                           0000D6   242 _AC	=	0x00d6
                           0000D7   243 _CY	=	0x00d7
                                    244 ;--------------------------------------------------------
                                    245 ; overlayable register banks
                                    246 ;--------------------------------------------------------
                                    247 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        248 	.ds 8
                                    249 ;--------------------------------------------------------
                                    250 ; internal ram data
                                    251 ;--------------------------------------------------------
                                    252 	.area DSEG    (DATA)
      000000                        253 _sel_seg_to_incr::
      000000                        254 	.ds 2
      000002                        255 _ret_seg_to_incre::
      000002                        256 	.ds 2
      000004                        257 _recnt_incr_seg::
      000004                        258 	.ds 2
      000006                        259 _begin::
      000006                        260 	.ds 2
      000008                        261 _dig_disp::
      000008                        262 	.ds 1
      000009                        263 _min2::
      000009                        264 	.ds 2
      00000B                        265 _min1::
      00000B                        266 	.ds 2
      00000D                        267 _sec2::
      00000D                        268 	.ds 2
      00000F                        269 _sec1::
      00000F                        270 	.ds 2
      000011                        271 _minalarm2::
      000011                        272 	.ds 2
      000013                        273 _minalarm1::
      000013                        274 	.ds 2
      000015                        275 _secalarm2::
      000015                        276 	.ds 2
      000017                        277 _secalarm1::
      000017                        278 	.ds 2
      000019                        279 _alarmmin2::
      000019                        280 	.ds 2
      00001B                        281 _alarmmin1::
      00001B                        282 	.ds 2
      00001D                        283 _alarmsec2::
      00001D                        284 	.ds 2
      00001F                        285 _alarmsec1::
      00001F                        286 	.ds 2
      000021                        287 _keepmin2::
      000021                        288 	.ds 2
      000023                        289 _keepmin1::
      000023                        290 	.ds 2
      000025                        291 _keepsec2::
      000025                        292 	.ds 2
      000027                        293 _keepsec1::
      000027                        294 	.ds 2
      000029                        295 _loop::
      000029                        296 	.ds 2
      00002B                        297 _mode::
      00002B                        298 	.ds 2
      00002D                        299 _dig_val::
      00002D                        300 	.ds 10
                                    301 ;--------------------------------------------------------
                                    302 ; overlayable items in internal ram 
                                    303 ;--------------------------------------------------------
                                    304 	.area	OSEG    (OVR,DATA)
                                    305 ;--------------------------------------------------------
                                    306 ; Stack segment in internal ram 
                                    307 ;--------------------------------------------------------
                                    308 	.area	SSEG
      000000                        309 __start__stack:
      000000                        310 	.ds	1
                                    311 
                                    312 ;--------------------------------------------------------
                                    313 ; indirectly addressable internal ram data
                                    314 ;--------------------------------------------------------
                                    315 	.area ISEG    (DATA)
                                    316 ;--------------------------------------------------------
                                    317 ; absolute internal ram data
                                    318 ;--------------------------------------------------------
                                    319 	.area IABS    (ABS,DATA)
                                    320 	.area IABS    (ABS,DATA)
                                    321 ;--------------------------------------------------------
                                    322 ; bit data
                                    323 ;--------------------------------------------------------
                                    324 	.area BSEG    (BIT)
                                    325 ;--------------------------------------------------------
                                    326 ; paged external ram data
                                    327 ;--------------------------------------------------------
                                    328 	.area PSEG    (PAG,XDATA)
                                    329 ;--------------------------------------------------------
                                    330 ; external ram data
                                    331 ;--------------------------------------------------------
                                    332 	.area XSEG    (XDATA)
                                    333 ;--------------------------------------------------------
                                    334 ; absolute external ram data
                                    335 ;--------------------------------------------------------
                                    336 	.area XABS    (ABS,XDATA)
                                    337 ;--------------------------------------------------------
                                    338 ; external initialized ram data
                                    339 ;--------------------------------------------------------
                                    340 	.area XISEG   (XDATA)
                                    341 	.area HOME    (CODE)
                                    342 	.area GSINIT0 (CODE)
                                    343 	.area GSINIT1 (CODE)
                                    344 	.area GSINIT2 (CODE)
                                    345 	.area GSINIT3 (CODE)
                                    346 	.area GSINIT4 (CODE)
                                    347 	.area GSINIT5 (CODE)
                                    348 	.area GSINIT  (CODE)
                                    349 	.area GSFINAL (CODE)
                                    350 	.area CSEG    (CODE)
                                    351 ;--------------------------------------------------------
                                    352 ; interrupt vector 
                                    353 ;--------------------------------------------------------
                                    354 	.area HOME    (CODE)
      000000                        355 __interrupt_vect:
      000000 02r00r00         [24]  356 	ljmp	__sdcc_gsinit_startup
      000003 32               [24]  357 	reti
      000004                        358 	.ds	7
      00000B 02r03rD7         [24]  359 	ljmp	_display
      00000E                        360 	.ds	5
      000013 32               [24]  361 	reti
      000014                        362 	.ds	7
      00001B 02r04r4F         [24]  363 	ljmp	_moveclock
                                    364 ;--------------------------------------------------------
                                    365 ; global & static initialisations
                                    366 ;--------------------------------------------------------
                                    367 	.area HOME    (CODE)
                                    368 	.area GSINIT  (CODE)
                                    369 	.area GSFINAL (CODE)
                                    370 	.area GSINIT  (CODE)
                                    371 	.globl __sdcc_gsinit_startup
                                    372 	.globl __sdcc_program_startup
                                    373 	.globl __start__stack
                                    374 	.globl __mcs51_genXINIT
                                    375 	.globl __mcs51_genXRAMCLEAR
                                    376 	.globl __mcs51_genRAMCLEAR
                                    377 ;	main.c:53: int sel_seg_to_incr     =   0;
      000000 E4               [12]  378 	clr	a
      000001 F5*00            [12]  379 	mov	_sel_seg_to_incr,a
      000003 F5*01            [12]  380 	mov	(_sel_seg_to_incr + 1),a
                                    381 ;	main.c:54: int ret_seg_to_incre    =   0;
      000005 F5*02            [12]  382 	mov	_ret_seg_to_incre,a
      000007 F5*03            [12]  383 	mov	(_ret_seg_to_incre + 1),a
                                    384 ;	main.c:57: unsigned char dig_disp  =   0;
                                    385 ;	1-genFromRTrack replaced	mov	_dig_disp,#0x00
      000009 F5*08            [12]  386 	mov	_dig_disp,a
                                    387 ;	main.c:58: int min2                =   0;
      00000B F5*09            [12]  388 	mov	_min2,a
      00000D F5*0A            [12]  389 	mov	(_min2 + 1),a
                                    390 ;	main.c:59: int min1                =   0;
      00000F F5*0B            [12]  391 	mov	_min1,a
      000011 F5*0C            [12]  392 	mov	(_min1 + 1),a
                                    393 ;	main.c:60: int sec2                =   0;
      000013 F5*0D            [12]  394 	mov	_sec2,a
      000015 F5*0E            [12]  395 	mov	(_sec2 + 1),a
                                    396 ;	main.c:61: int sec1                =   0;
      000017 F5*0F            [12]  397 	mov	_sec1,a
      000019 F5*10            [12]  398 	mov	(_sec1 + 1),a
                                    399 ;	main.c:62: int minalarm2           =   0;
      00001B F5*11            [12]  400 	mov	_minalarm2,a
      00001D F5*12            [12]  401 	mov	(_minalarm2 + 1),a
                                    402 ;	main.c:63: int minalarm1           =   0;
      00001F F5*13            [12]  403 	mov	_minalarm1,a
      000021 F5*14            [12]  404 	mov	(_minalarm1 + 1),a
                                    405 ;	main.c:64: int secalarm2           =   0;
      000023 F5*15            [12]  406 	mov	_secalarm2,a
      000025 F5*16            [12]  407 	mov	(_secalarm2 + 1),a
                                    408 ;	main.c:65: int secalarm1           =   0;
      000027 F5*17            [12]  409 	mov	_secalarm1,a
      000029 F5*18            [12]  410 	mov	(_secalarm1 + 1),a
                                    411 ;	main.c:66: int alarmmin2           =   0;
      00002B F5*19            [12]  412 	mov	_alarmmin2,a
      00002D F5*1A            [12]  413 	mov	(_alarmmin2 + 1),a
                                    414 ;	main.c:67: int alarmmin1           =   0;
      00002F F5*1B            [12]  415 	mov	_alarmmin1,a
      000031 F5*1C            [12]  416 	mov	(_alarmmin1 + 1),a
                                    417 ;	main.c:68: int alarmsec2           =   0;
      000033 F5*1D            [12]  418 	mov	_alarmsec2,a
      000035 F5*1E            [12]  419 	mov	(_alarmsec2 + 1),a
                                    420 ;	main.c:69: int alarmsec1           =   0;
      000037 F5*1F            [12]  421 	mov	_alarmsec1,a
      000039 F5*20            [12]  422 	mov	(_alarmsec1 + 1),a
                                    423 ;	main.c:70: int keepmin2            =   0;
      00003B F5*21            [12]  424 	mov	_keepmin2,a
      00003D F5*22            [12]  425 	mov	(_keepmin2 + 1),a
                                    426 ;	main.c:71: int keepmin1            =   0;
      00003F F5*23            [12]  427 	mov	_keepmin1,a
      000041 F5*24            [12]  428 	mov	(_keepmin1 + 1),a
                                    429 ;	main.c:72: int keepsec2            =   0;
      000043 F5*25            [12]  430 	mov	_keepsec2,a
      000045 F5*26            [12]  431 	mov	(_keepsec2 + 1),a
                                    432 ;	main.c:73: int keepsec1            =   0;
      000047 F5*27            [12]  433 	mov	_keepsec1,a
      000049 F5*28            [12]  434 	mov	(_keepsec1 + 1),a
                                    435 ;	main.c:74: int loop                =   0;
      00004B F5*29            [12]  436 	mov	_loop,a
      00004D F5*2A            [12]  437 	mov	(_loop + 1),a
                                    438 ;	main.c:76: char dig_val[10]        =   {0x40,0xF9,0x24,0x30,0x19,0x12,0x02,0xF8,0x00,0x10};  // Hex values corresponding to digits 0 to 9
      00004F 75*2D 40         [24]  439 	mov	_dig_val,#0x40
      000052 75*2E F9         [24]  440 	mov	(_dig_val + 0x0001),#0xf9
      000055 75*2F 24         [24]  441 	mov	(_dig_val + 0x0002),#0x24
      000058 75*30 30         [24]  442 	mov	(_dig_val + 0x0003),#0x30
      00005B 75*31 19         [24]  443 	mov	(_dig_val + 0x0004),#0x19
      00005E 75*32 12         [24]  444 	mov	(_dig_val + 0x0005),#0x12
      000061 75*33 02         [24]  445 	mov	(_dig_val + 0x0006),#0x02
      000064 75*34 F8         [24]  446 	mov	(_dig_val + 0x0007),#0xf8
                                    447 ;	1-genFromRTrack replaced	mov	(_dig_val + 0x0008),#0x00
      000067 F5*35            [12]  448 	mov	(_dig_val + 0x0008),a
      000069 75*36 10         [24]  449 	mov	(_dig_val + 0x0009),#0x10
                                    450 	.area GSFINAL (CODE)
      000000 02r00r1E         [24]  451 	ljmp	__sdcc_program_startup
                                    452 ;--------------------------------------------------------
                                    453 ; Home
                                    454 ;--------------------------------------------------------
                                    455 	.area HOME    (CODE)
                                    456 	.area HOME    (CODE)
      00001E                        457 __sdcc_program_startup:
      00001E 02r04rF0         [24]  458 	ljmp	_main
                                    459 ;	return from main will return to caller
                                    460 ;--------------------------------------------------------
                                    461 ; code
                                    462 ;--------------------------------------------------------
                                    463 	.area CSEG    (CODE)
                                    464 ;------------------------------------------------------------
                                    465 ;Allocation info for local variables in function 'delay'
                                    466 ;------------------------------------------------------------
                                    467 ;time                      Allocated to registers r6 r7 
                                    468 ;i                         Allocated to registers r4 r5 
                                    469 ;j                         Allocated to registers r2 r3 
                                    470 ;------------------------------------------------------------
                                    471 ;	main.c:78: void delay(int time)  //Function to provide time delay.
                                    472 ;	-----------------------------------------
                                    473 ;	 function delay
                                    474 ;	-----------------------------------------
      000000                        475 _delay:
                           000007   476 	ar7 = 0x07
                           000006   477 	ar6 = 0x06
                           000005   478 	ar5 = 0x05
                           000004   479 	ar4 = 0x04
                           000003   480 	ar3 = 0x03
                           000002   481 	ar2 = 0x02
                           000001   482 	ar1 = 0x01
                           000000   483 	ar0 = 0x00
      000000 AE 82            [24]  484 	mov	r6,dpl
      000002 AF 83            [24]  485 	mov	r7,dph
                                    486 ;	main.c:81: for(i=0;i<time;i++)
      000004 7C 00            [12]  487 	mov	r4,#0x00
      000006 7D 00            [12]  488 	mov	r5,#0x00
      000008                        489 00107$:
      000008 C3               [12]  490 	clr	c
      000009 EC               [12]  491 	mov	a,r4
      00000A 9E               [12]  492 	subb	a,r6
      00000B ED               [12]  493 	mov	a,r5
      00000C 64 80            [12]  494 	xrl	a,#0x80
      00000E 8F F0            [24]  495 	mov	b,r7
      000010 63 F0 80         [24]  496 	xrl	b,#0x80
      000013 95 F0            [12]  497 	subb	a,b
      000015 50 1B            [24]  498 	jnc	00109$
                                    499 ;	main.c:82: for(j=0;j<1275;j++);
      000017 7A FB            [12]  500 	mov	r2,#0xfb
      000019 7B 04            [12]  501 	mov	r3,#0x04
      00001B                        502 00105$:
      00001B EA               [12]  503 	mov	a,r2
      00001C 24 FF            [12]  504 	add	a,#0xff
      00001E F8               [12]  505 	mov	r0,a
      00001F EB               [12]  506 	mov	a,r3
      000020 34 FF            [12]  507 	addc	a,#0xff
      000022 F9               [12]  508 	mov	r1,a
      000023 88 02            [24]  509 	mov	ar2,r0
      000025 89 03            [24]  510 	mov	ar3,r1
      000027 E8               [12]  511 	mov	a,r0
      000028 49               [12]  512 	orl	a,r1
      000029 70 F0            [24]  513 	jnz	00105$
                                    514 ;	main.c:81: for(i=0;i<time;i++)
      00002B 0C               [12]  515 	inc	r4
      00002C BC 00 D9         [24]  516 	cjne	r4,#0x00,00107$
      00002F 0D               [12]  517 	inc	r5
      000030 80 D6            [24]  518 	sjmp	00107$
      000032                        519 00109$:
      000032 22               [24]  520 	ret
                                    521 ;------------------------------------------------------------
                                    522 ;Allocation info for local variables in function 'setfn'
                                    523 ;------------------------------------------------------------
                                    524 ;	main.c:85: int setfn(void)  // Function to select miniute and seconds digit set time.
                                    525 ;	-----------------------------------------
                                    526 ;	 function setfn
                                    527 ;	-----------------------------------------
      000033                        528 _setfn:
                                    529 ;	main.c:87: while(set==0)
      000033                        530 00114$:
      000033 30 96 03         [24]  531 	jnb	_P1_6,00149$
      000036 02r01r03         [24]  532 	ljmp	00116$
      000039                        533 00149$:
                                    534 ;	main.c:89: switch(recnt_incr_seg)
      000039 74 01            [12]  535 	mov	a,#0x01
      00003B B5*04 06         [24]  536 	cjne	a,_recnt_incr_seg,00150$
      00003E 14               [12]  537 	dec	a
      00003F B5*05 02         [24]  538 	cjne	a,(_recnt_incr_seg + 1),00150$
      000042 80 23            [24]  539 	sjmp	00101$
      000044                        540 00150$:
      000044 74 02            [12]  541 	mov	a,#0x02
      000046 B5*04 06         [24]  542 	cjne	a,_recnt_incr_seg,00151$
      000049 E4               [12]  543 	clr	a
      00004A B5*05 02         [24]  544 	cjne	a,(_recnt_incr_seg + 1),00151$
      00004D 80 3C            [24]  545 	sjmp	00104$
      00004F                        546 00151$:
      00004F 74 03            [12]  547 	mov	a,#0x03
      000051 B5*04 06         [24]  548 	cjne	a,_recnt_incr_seg,00152$
      000054 E4               [12]  549 	clr	a
      000055 B5*05 02         [24]  550 	cjne	a,(_recnt_incr_seg + 1),00152$
      000058 80 55            [24]  551 	sjmp	00107$
      00005A                        552 00152$:
      00005A 74 04            [12]  553 	mov	a,#0x04
      00005C B5*04 06         [24]  554 	cjne	a,_recnt_incr_seg,00153$
      00005F E4               [12]  555 	clr	a
      000060 B5*05 02         [24]  556 	cjne	a,(_recnt_incr_seg + 1),00153$
      000063 80 6E            [24]  557 	sjmp	00110$
      000065                        558 00153$:
                                    559 ;	main.c:91: case 1:
      000065 80 CC            [24]  560 	sjmp	00114$
      000067                        561 00101$:
                                    562 ;	main.c:92: if(set==0)  //Select the min2 digit
      000067 20 96 21         [24]  563 	jb	_P1_6,00104$
                                    564 ;	main.c:94: dig_ctrl_4      =   1;
      00006A D2 90            [12]  565 	setb	_P1_0
                                    566 ;	main.c:95: dig_ctrl_3      =   0;
      00006C C2 91            [12]  567 	clr	_P1_1
                                    568 ;	main.c:96: dig_ctrl_2      =   0;
      00006E C2 92            [12]  569 	clr	_P1_2
                                    570 ;	main.c:97: dig_ctrl_1      =   0;
      000070 C2 93            [12]  571 	clr	_P1_3
                                    572 ;	main.c:98: recnt_incr_seg  =   1;
      000072 75*04 01         [24]  573 	mov	_recnt_incr_seg,#0x01
      000075 75*05 00         [24]  574 	mov	(_recnt_incr_seg + 1),#0x00
                                    575 ;	main.c:99: ret_seg_to_incre=   1;
      000078 75*02 01         [24]  576 	mov	_ret_seg_to_incre,#0x01
      00007B 75*03 00         [24]  577 	mov	(_ret_seg_to_incre + 1),#0x00
                                    578 ;	main.c:100: P2              =   dig_val[minalarm2];
      00007E E5*11            [12]  579 	mov	a,_minalarm2
      000080 24r2D            [12]  580 	add	a,#_dig_val
      000082 F9               [12]  581 	mov	r1,a
      000083 87 A0            [24]  582 	mov	_P2,@r1
                                    583 ;	main.c:101: delay(100);
      000085 90 00 64         [24]  584 	mov	dptr,#0x0064
      000088 12r00r00         [24]  585 	lcall	_delay
                                    586 ;	main.c:103: case 2:
      00008B                        587 00104$:
                                    588 ;	main.c:104: if(set==0)  //Select the min1 digit
      00008B 20 96 21         [24]  589 	jb	_P1_6,00107$
                                    590 ;	main.c:106: dig_ctrl_4      =   0;
      00008E C2 90            [12]  591 	clr	_P1_0
                                    592 ;	main.c:107: dig_ctrl_3      =   1;
      000090 D2 91            [12]  593 	setb	_P1_1
                                    594 ;	main.c:108: dig_ctrl_2      =   0;
      000092 C2 92            [12]  595 	clr	_P1_2
                                    596 ;	main.c:109: dig_ctrl_1      =   0;
      000094 C2 93            [12]  597 	clr	_P1_3
                                    598 ;	main.c:110: recnt_incr_seg  =   2;
      000096 75*04 02         [24]  599 	mov	_recnt_incr_seg,#0x02
      000099 75*05 00         [24]  600 	mov	(_recnt_incr_seg + 1),#0x00
                                    601 ;	main.c:111: ret_seg_to_incre=   2;
      00009C 75*02 02         [24]  602 	mov	_ret_seg_to_incre,#0x02
      00009F 75*03 00         [24]  603 	mov	(_ret_seg_to_incre + 1),#0x00
                                    604 ;	main.c:112: P2              =   dig_val[minalarm1];
      0000A2 E5*13            [12]  605 	mov	a,_minalarm1
      0000A4 24r2D            [12]  606 	add	a,#_dig_val
      0000A6 F9               [12]  607 	mov	r1,a
      0000A7 87 A0            [24]  608 	mov	_P2,@r1
                                    609 ;	main.c:113: delay(100);
      0000A9 90 00 64         [24]  610 	mov	dptr,#0x0064
      0000AC 12r00r00         [24]  611 	lcall	_delay
                                    612 ;	main.c:115: case 3:
      0000AF                        613 00107$:
                                    614 ;	main.c:116: if(set==0)  //Select the sec 2 digit
      0000AF 20 96 21         [24]  615 	jb	_P1_6,00110$
                                    616 ;	main.c:118: dig_ctrl_4      =   0;
      0000B2 C2 90            [12]  617 	clr	_P1_0
                                    618 ;	main.c:119: dig_ctrl_3      =   0;
      0000B4 C2 91            [12]  619 	clr	_P1_1
                                    620 ;	main.c:120: dig_ctrl_2      =   1;
      0000B6 D2 92            [12]  621 	setb	_P1_2
                                    622 ;	main.c:121: dig_ctrl_1      =   0;
      0000B8 C2 93            [12]  623 	clr	_P1_3
                                    624 ;	main.c:122: recnt_incr_seg  =   3;
      0000BA 75*04 03         [24]  625 	mov	_recnt_incr_seg,#0x03
      0000BD 75*05 00         [24]  626 	mov	(_recnt_incr_seg + 1),#0x00
                                    627 ;	main.c:123: ret_seg_to_incre=   3;
      0000C0 75*02 03         [24]  628 	mov	_ret_seg_to_incre,#0x03
      0000C3 75*03 00         [24]  629 	mov	(_ret_seg_to_incre + 1),#0x00
                                    630 ;	main.c:124: P2              =   dig_val[secalarm2];
      0000C6 E5*15            [12]  631 	mov	a,_secalarm2
      0000C8 24r2D            [12]  632 	add	a,#_dig_val
      0000CA F9               [12]  633 	mov	r1,a
      0000CB 87 A0            [24]  634 	mov	_P2,@r1
                                    635 ;	main.c:125: delay(100);
      0000CD 90 00 64         [24]  636 	mov	dptr,#0x0064
      0000D0 12r00r00         [24]  637 	lcall	_delay
                                    638 ;	main.c:127: case 4:
      0000D3                        639 00110$:
                                    640 ;	main.c:128: if(set==0)  //Select the sec1 digit
      0000D3 30 96 03         [24]  641 	jnb	_P1_6,00157$
      0000D6 02r00r33         [24]  642 	ljmp	00114$
      0000D9                        643 00157$:
                                    644 ;	main.c:130: recnt_incr_seg  =   1;
      0000D9 75*04 01         [24]  645 	mov	_recnt_incr_seg,#0x01
      0000DC 75*05 00         [24]  646 	mov	(_recnt_incr_seg + 1),#0x00
                                    647 ;	main.c:131: dig_ctrl_4      =   0;
      0000DF C2 90            [12]  648 	clr	_P1_0
                                    649 ;	main.c:132: dig_ctrl_3      =   0;
      0000E1 C2 91            [12]  650 	clr	_P1_1
                                    651 ;	main.c:133: dig_ctrl_2      =   0;
      0000E3 C2 92            [12]  652 	clr	_P1_2
                                    653 ;	main.c:134: dig_ctrl_1      =   1;
      0000E5 D2 93            [12]  654 	setb	_P1_3
                                    655 ;	main.c:135: ret_seg_to_incre=   4;
      0000E7 75*02 04         [24]  656 	mov	_ret_seg_to_incre,#0x04
      0000EA 75*03 00         [24]  657 	mov	(_ret_seg_to_incre + 1),#0x00
                                    658 ;	main.c:136: P2              =   dig_val[secalarm1];
      0000ED E5*17            [12]  659 	mov	a,_secalarm1
      0000EF 24r2D            [12]  660 	add	a,#_dig_val
      0000F1 F9               [12]  661 	mov	r1,a
      0000F2 87 A0            [24]  662 	mov	_P2,@r1
                                    663 ;	main.c:137: delay(100);
      0000F4 90 00 64         [24]  664 	mov	dptr,#0x0064
      0000F7 12r00r00         [24]  665 	lcall	_delay
                                    666 ;	main.c:138: recnt_incr_seg  =   1;
      0000FA 75*04 01         [24]  667 	mov	_recnt_incr_seg,#0x01
      0000FD 75*05 00         [24]  668 	mov	(_recnt_incr_seg + 1),#0x00
                                    669 ;	main.c:140: }
      000100 02r00r33         [24]  670 	ljmp	00114$
      000103                        671 00116$:
                                    672 ;	main.c:142: return(ret_seg_to_incre);
      000103 85*02 82         [24]  673 	mov	dpl,_ret_seg_to_incre
      000106 85*03 83         [24]  674 	mov	dph,(_ret_seg_to_incre + 1)
      000109 22               [24]  675 	ret
                                    676 ;------------------------------------------------------------
                                    677 ;Allocation info for local variables in function 'increase'
                                    678 ;------------------------------------------------------------
                                    679 ;a                         Allocated to registers r6 r7 
                                    680 ;------------------------------------------------------------
                                    681 ;	main.c:145: void increase(int a)  //Function to set the minutes or seconds digit
                                    682 ;	-----------------------------------------
                                    683 ;	 function increase
                                    684 ;	-----------------------------------------
      00010A                        685 _increase:
      00010A AE 82            [24]  686 	mov	r6,dpl
      00010C AF 83            [24]  687 	mov	r7,dph
                                    688 ;	main.c:147: while(incr==0)
      00010E BE 01 06         [24]  689 	cjne	r6,#0x01,00149$
      000111 BF 00 03         [24]  690 	cjne	r7,#0x00,00149$
      000114 EE               [12]  691 	mov	a,r6
      000115 80 01            [24]  692 	sjmp	00150$
      000117                        693 00149$:
      000117 E4               [12]  694 	clr	a
      000118                        695 00150$:
      000118 FD               [12]  696 	mov	r5,a
      000119 E4               [12]  697 	clr	a
      00011A BE 02 04         [24]  698 	cjne	r6,#0x02,00151$
      00011D BF 00 01         [24]  699 	cjne	r7,#0x00,00151$
      000120 04               [12]  700 	inc	a
      000121                        701 00151$:
      000121 FC               [12]  702 	mov	r4,a
      000122 E4               [12]  703 	clr	a
      000123 BE 03 04         [24]  704 	cjne	r6,#0x03,00153$
      000126 BF 00 01         [24]  705 	cjne	r7,#0x00,00153$
      000129 04               [12]  706 	inc	a
      00012A                        707 00153$:
      00012A FB               [12]  708 	mov	r3,a
      00012B E4               [12]  709 	clr	a
      00012C BE 04 04         [24]  710 	cjne	r6,#0x04,00155$
      00012F BF 00 01         [24]  711 	cjne	r7,#0x00,00155$
      000132 04               [12]  712 	inc	a
      000133                        713 00155$:
      000133 FF               [12]  714 	mov	r7,a
      000134                        715 00114$:
      000134 30 97 01         [24]  716 	jnb	_P1_7,00157$
      000137 22               [24]  717 	ret
      000138                        718 00157$:
                                    719 ;	main.c:149: switch(a)
      000138 ED               [12]  720 	mov	a,r5
      000139 70 0F            [24]  721 	jnz	00101$
      00013B EC               [12]  722 	mov	a,r4
      00013C 70 62            [24]  723 	jnz	00104$
      00013E EB               [12]  724 	mov	a,r3
      00013F 60 03            [24]  725 	jz	00160$
      000141 02r01rF7         [24]  726 	ljmp	00107$
      000144                        727 00160$:
      000144 EF               [12]  728 	mov	a,r7
      000145 60 ED            [24]  729 	jz	00114$
                                    730 ;	main.c:151: case 1:  // Set the min2 digit.
      000147 02r02r4E         [24]  731 	ljmp	00110$
      00014A                        732 00101$:
                                    733 ;	main.c:152: P2 = dig_val[minalarm2];
      00014A E5*11            [12]  734 	mov	a,_minalarm2
      00014C 24r2D            [12]  735 	add	a,#_dig_val
      00014E F9               [12]  736 	mov	r1,a
      00014F 87 A0            [24]  737 	mov	_P2,@r1
                                    738 ;	main.c:153: delay(100);
      000151 90 00 64         [24]  739 	mov	dptr,#0x0064
      000154 C0 07            [24]  740 	push	ar7
      000156 C0 05            [24]  741 	push	ar5
      000158 C0 04            [24]  742 	push	ar4
      00015A C0 03            [24]  743 	push	ar3
      00015C 12r00r00         [24]  744 	lcall	_delay
      00015F D0 03            [24]  745 	pop	ar3
      000161 D0 04            [24]  746 	pop	ar4
      000163 D0 05            [24]  747 	pop	ar5
      000165 D0 07            [24]  748 	pop	ar7
                                    749 ;	main.c:154: minalarm2++;
      000167 05*11            [12]  750 	inc	_minalarm2
      000169 E4               [12]  751 	clr	a
      00016A B5*11 02         [24]  752 	cjne	a,_minalarm2,00162$
      00016D 05*12            [12]  753 	inc	(_minalarm2 + 1)
      00016F                        754 00162$:
                                    755 ;	main.c:155: if(minalarm2==6) minalarm2 = 0;
      00016F 74 06            [12]  756 	mov	a,#0x06
      000171 B5*11 06         [24]  757 	cjne	a,_minalarm2,00163$
      000174 E4               [12]  758 	clr	a
      000175 B5*12 02         [24]  759 	cjne	a,(_minalarm2 + 1),00163$
      000178 80 02            [24]  760 	sjmp	00164$
      00017A                        761 00163$:
      00017A 80 05            [24]  762 	sjmp	00103$
      00017C                        763 00164$:
      00017C E4               [12]  764 	clr	a
      00017D F5*11            [12]  765 	mov	_minalarm2,a
      00017F F5*12            [12]  766 	mov	(_minalarm2 + 1),a
      000181                        767 00103$:
                                    768 ;	main.c:156: P2 = dig_val[minalarm2];
      000181 E5*11            [12]  769 	mov	a,_minalarm2
      000183 24r2D            [12]  770 	add	a,#_dig_val
      000185 F9               [12]  771 	mov	r1,a
      000186 87 A0            [24]  772 	mov	_P2,@r1
                                    773 ;	main.c:157: delay(20);
      000188 90 00 14         [24]  774 	mov	dptr,#0x0014
      00018B C0 07            [24]  775 	push	ar7
      00018D C0 05            [24]  776 	push	ar5
      00018F C0 04            [24]  777 	push	ar4
      000191 C0 03            [24]  778 	push	ar3
      000193 12r00r00         [24]  779 	lcall	_delay
      000196 D0 03            [24]  780 	pop	ar3
      000198 D0 04            [24]  781 	pop	ar4
      00019A D0 05            [24]  782 	pop	ar5
      00019C D0 07            [24]  783 	pop	ar7
                                    784 ;	main.c:158: break;
                                    785 ;	main.c:159: case 2:  //Set the min1 digit.
      00019E 80 94            [24]  786 	sjmp	00114$
      0001A0                        787 00104$:
                                    788 ;	main.c:160: P2 = dig_val[minalarm1];
      0001A0 E5*13            [12]  789 	mov	a,_minalarm1
      0001A2 24r2D            [12]  790 	add	a,#_dig_val
      0001A4 F9               [12]  791 	mov	r1,a
      0001A5 87 A0            [24]  792 	mov	_P2,@r1
                                    793 ;	main.c:161: delay(100);
      0001A7 90 00 64         [24]  794 	mov	dptr,#0x0064
      0001AA C0 07            [24]  795 	push	ar7
      0001AC C0 05            [24]  796 	push	ar5
      0001AE C0 04            [24]  797 	push	ar4
      0001B0 C0 03            [24]  798 	push	ar3
      0001B2 12r00r00         [24]  799 	lcall	_delay
      0001B5 D0 03            [24]  800 	pop	ar3
      0001B7 D0 04            [24]  801 	pop	ar4
      0001B9 D0 05            [24]  802 	pop	ar5
      0001BB D0 07            [24]  803 	pop	ar7
                                    804 ;	main.c:162: minalarm1++;
      0001BD 05*13            [12]  805 	inc	_minalarm1
      0001BF E4               [12]  806 	clr	a
      0001C0 B5*13 02         [24]  807 	cjne	a,_minalarm1,00165$
      0001C3 05*14            [12]  808 	inc	(_minalarm1 + 1)
      0001C5                        809 00165$:
                                    810 ;	main.c:163: if(minalarm1==10)
      0001C5 74 0A            [12]  811 	mov	a,#0x0a
      0001C7 B5*13 06         [24]  812 	cjne	a,_minalarm1,00166$
      0001CA E4               [12]  813 	clr	a
      0001CB B5*14 02         [24]  814 	cjne	a,(_minalarm1 + 1),00166$
      0001CE 80 02            [24]  815 	sjmp	00167$
      0001D0                        816 00166$:
      0001D0 80 05            [24]  817 	sjmp	00106$
      0001D2                        818 00167$:
                                    819 ;	main.c:164: minalarm1 = 0;
      0001D2 E4               [12]  820 	clr	a
      0001D3 F5*13            [12]  821 	mov	_minalarm1,a
      0001D5 F5*14            [12]  822 	mov	(_minalarm1 + 1),a
      0001D7                        823 00106$:
                                    824 ;	main.c:165: P2 = dig_val[minalarm1];
      0001D7 E5*13            [12]  825 	mov	a,_minalarm1
      0001D9 24r2D            [12]  826 	add	a,#_dig_val
      0001DB F9               [12]  827 	mov	r1,a
      0001DC 87 A0            [24]  828 	mov	_P2,@r1
                                    829 ;	main.c:166: delay(20);
      0001DE 90 00 14         [24]  830 	mov	dptr,#0x0014
      0001E1 C0 07            [24]  831 	push	ar7
      0001E3 C0 05            [24]  832 	push	ar5
      0001E5 C0 04            [24]  833 	push	ar4
      0001E7 C0 03            [24]  834 	push	ar3
      0001E9 12r00r00         [24]  835 	lcall	_delay
      0001EC D0 03            [24]  836 	pop	ar3
      0001EE D0 04            [24]  837 	pop	ar4
      0001F0 D0 05            [24]  838 	pop	ar5
      0001F2 D0 07            [24]  839 	pop	ar7
                                    840 ;	main.c:167: break;
      0001F4 02r01r34         [24]  841 	ljmp	00114$
                                    842 ;	main.c:168: case 3:  // Set the sec2 digit.
      0001F7                        843 00107$:
                                    844 ;	main.c:169: P2 = dig_val[secalarm2];
      0001F7 E5*15            [12]  845 	mov	a,_secalarm2
      0001F9 24r2D            [12]  846 	add	a,#_dig_val
      0001FB F9               [12]  847 	mov	r1,a
      0001FC 87 A0            [24]  848 	mov	_P2,@r1
                                    849 ;	main.c:170: delay(100);
      0001FE 90 00 64         [24]  850 	mov	dptr,#0x0064
      000201 C0 07            [24]  851 	push	ar7
      000203 C0 05            [24]  852 	push	ar5
      000205 C0 04            [24]  853 	push	ar4
      000207 C0 03            [24]  854 	push	ar3
      000209 12r00r00         [24]  855 	lcall	_delay
      00020C D0 03            [24]  856 	pop	ar3
      00020E D0 04            [24]  857 	pop	ar4
      000210 D0 05            [24]  858 	pop	ar5
      000212 D0 07            [24]  859 	pop	ar7
                                    860 ;	main.c:171: secalarm2++;
      000214 05*15            [12]  861 	inc	_secalarm2
      000216 E4               [12]  862 	clr	a
      000217 B5*15 02         [24]  863 	cjne	a,_secalarm2,00168$
      00021A 05*16            [12]  864 	inc	(_secalarm2 + 1)
      00021C                        865 00168$:
                                    866 ;	main.c:172: if(secalarm2==6)
      00021C 74 06            [12]  867 	mov	a,#0x06
      00021E B5*15 06         [24]  868 	cjne	a,_secalarm2,00169$
      000221 E4               [12]  869 	clr	a
      000222 B5*16 02         [24]  870 	cjne	a,(_secalarm2 + 1),00169$
      000225 80 02            [24]  871 	sjmp	00170$
      000227                        872 00169$:
      000227 80 05            [24]  873 	sjmp	00109$
      000229                        874 00170$:
                                    875 ;	main.c:173: secalarm2 = 0;
      000229 E4               [12]  876 	clr	a
      00022A F5*15            [12]  877 	mov	_secalarm2,a
      00022C F5*16            [12]  878 	mov	(_secalarm2 + 1),a
      00022E                        879 00109$:
                                    880 ;	main.c:174: P2 = dig_val[secalarm2];
      00022E E5*15            [12]  881 	mov	a,_secalarm2
      000230 24r2D            [12]  882 	add	a,#_dig_val
      000232 F9               [12]  883 	mov	r1,a
      000233 87 A0            [24]  884 	mov	_P2,@r1
                                    885 ;	main.c:175: delay(20);
      000235 90 00 14         [24]  886 	mov	dptr,#0x0014
      000238 C0 07            [24]  887 	push	ar7
      00023A C0 05            [24]  888 	push	ar5
      00023C C0 04            [24]  889 	push	ar4
      00023E C0 03            [24]  890 	push	ar3
      000240 12r00r00         [24]  891 	lcall	_delay
      000243 D0 03            [24]  892 	pop	ar3
      000245 D0 04            [24]  893 	pop	ar4
      000247 D0 05            [24]  894 	pop	ar5
      000249 D0 07            [24]  895 	pop	ar7
                                    896 ;	main.c:176: break;
      00024B 02r01r34         [24]  897 	ljmp	00114$
                                    898 ;	main.c:177: case 4:  //Set the sec1 digit.
      00024E                        899 00110$:
                                    900 ;	main.c:179: P2 = dig_val[secalarm1];
      00024E E5*17            [12]  901 	mov	a,_secalarm1
      000250 24r2D            [12]  902 	add	a,#_dig_val
      000252 F9               [12]  903 	mov	r1,a
      000253 87 A0            [24]  904 	mov	_P2,@r1
                                    905 ;	main.c:180: delay(100);
      000255 90 00 64         [24]  906 	mov	dptr,#0x0064
      000258 C0 07            [24]  907 	push	ar7
      00025A C0 05            [24]  908 	push	ar5
      00025C C0 04            [24]  909 	push	ar4
      00025E C0 03            [24]  910 	push	ar3
      000260 12r00r00         [24]  911 	lcall	_delay
      000263 D0 03            [24]  912 	pop	ar3
      000265 D0 04            [24]  913 	pop	ar4
      000267 D0 05            [24]  914 	pop	ar5
      000269 D0 07            [24]  915 	pop	ar7
                                    916 ;	main.c:181: secalarm1++;
      00026B 05*17            [12]  917 	inc	_secalarm1
      00026D E4               [12]  918 	clr	a
      00026E B5*17 02         [24]  919 	cjne	a,_secalarm1,00171$
      000271 05*18            [12]  920 	inc	(_secalarm1 + 1)
      000273                        921 00171$:
                                    922 ;	main.c:182: if(secalarm1==10)
      000273 74 0A            [12]  923 	mov	a,#0x0a
      000275 B5*17 06         [24]  924 	cjne	a,_secalarm1,00172$
      000278 E4               [12]  925 	clr	a
      000279 B5*18 02         [24]  926 	cjne	a,(_secalarm1 + 1),00172$
      00027C 80 02            [24]  927 	sjmp	00173$
      00027E                        928 00172$:
      00027E 80 05            [24]  929 	sjmp	00112$
      000280                        930 00173$:
                                    931 ;	main.c:183: secalarm1 = 0;
      000280 E4               [12]  932 	clr	a
      000281 F5*17            [12]  933 	mov	_secalarm1,a
      000283 F5*18            [12]  934 	mov	(_secalarm1 + 1),a
      000285                        935 00112$:
                                    936 ;	main.c:184: P2 = dig_val[secalarm1];
      000285 E5*17            [12]  937 	mov	a,_secalarm1
      000287 24r2D            [12]  938 	add	a,#_dig_val
      000289 F9               [12]  939 	mov	r1,a
      00028A 87 A0            [24]  940 	mov	_P2,@r1
                                    941 ;	main.c:185: delay(20);
      00028C 90 00 14         [24]  942 	mov	dptr,#0x0014
      00028F C0 07            [24]  943 	push	ar7
      000291 C0 05            [24]  944 	push	ar5
      000293 C0 04            [24]  945 	push	ar4
      000295 C0 03            [24]  946 	push	ar3
      000297 12r00r00         [24]  947 	lcall	_delay
      00029A D0 03            [24]  948 	pop	ar3
      00029C D0 04            [24]  949 	pop	ar4
      00029E D0 05            [24]  950 	pop	ar5
      0002A0 D0 07            [24]  951 	pop	ar7
                                    952 ;	main.c:187: }
      0002A2 02r01r34         [24]  953 	ljmp	00114$
                                    954 ;------------------------------------------------------------
                                    955 ;Allocation info for local variables in function 'resetfn'
                                    956 ;------------------------------------------------------------
                                    957 ;mode                      Allocated to registers r6 r7 
                                    958 ;------------------------------------------------------------
                                    959 ;	main.c:191: void resetfn(int mode)  // Function to bring the clock to reset or set mode.
                                    960 ;	-----------------------------------------
                                    961 ;	 function resetfn
                                    962 ;	-----------------------------------------
      0002A5                        963 _resetfn:
      0002A5 AE 82            [24]  964 	mov	r6,dpl
      0002A7 AF 83            [24]  965 	mov	r7,dph
                                    966 ;	main.c:193: begin       = 1;
      0002A9 75*06 01         [24]  967 	mov	_begin,#0x01
      0002AC 75*07 00         [24]  968 	mov	(_begin + 1),#0x00
                                    969 ;	main.c:194: dig_ctrl_4  = 1;  //Enable the min2 digit and disable others
      0002AF D2 90            [12]  970 	setb	_P1_0
                                    971 ;	main.c:195: dig_ctrl_3  = 0;
      0002B1 C2 91            [12]  972 	clr	_P1_1
                                    973 ;	main.c:196: dig_ctrl_2  = 0;
      0002B3 C2 92            [12]  974 	clr	_P1_2
                                    975 ;	main.c:197: dig_ctrl_1  = 0;
      0002B5 C2 93            [12]  976 	clr	_P1_3
                                    977 ;	main.c:199: if(mode==0)  //Check if clock is in set alarm mode
      0002B7 EE               [12]  978 	mov	a,r6
      0002B8 4F               [12]  979 	orl	a,r7
                                    980 ;	main.c:201: IE              =   0x88;  //Disable Timer0 interrupt to stop the display of clock.
                                    981 ;	main.c:202: sel_seg_to_incr =   1;
      0002B9 70 3B            [24]  982 	jnz	00102$
      0002BB 75 A8 88         [24]  983 	mov	_IE,#0x88
      0002BE 75*00 01         [24]  984 	mov	_sel_seg_to_incr,#0x01
      0002C1 F5*01            [12]  985 	mov	(_sel_seg_to_incr + 1),a
                                    986 ;	main.c:203: recnt_incr_seg  =   1;
      0002C3 75*04 01         [24]  987 	mov	_recnt_incr_seg,#0x01
      0002C6 75*05 00         [24]  988 	mov	(_recnt_incr_seg + 1),#0x00
                                    989 ;	main.c:204: P2              =   dig_val[keepmin2];
      0002C9 E5*21            [12]  990 	mov	a,_keepmin2
      0002CB 24r2D            [12]  991 	add	a,#_dig_val
      0002CD F9               [12]  992 	mov	r1,a
      0002CE 87 A0            [24]  993 	mov	_P2,@r1
                                    994 ;	main.c:205: delay(100);
      0002D0 90 00 64         [24]  995 	mov	dptr,#0x0064
      0002D3 C0 07            [24]  996 	push	ar7
      0002D5 C0 06            [24]  997 	push	ar6
      0002D7 12r00r00         [24]  998 	lcall	_delay
      0002DA D0 06            [24]  999 	pop	ar6
      0002DC D0 07            [24] 1000 	pop	ar7
                                   1001 ;	main.c:206: minalarm2       =   keepmin2;
      0002DE 85*21*11         [24] 1002 	mov	_minalarm2,_keepmin2
      0002E1 85*22*12         [24] 1003 	mov	(_minalarm2 + 1),(_keepmin2 + 1)
                                   1004 ;	main.c:207: minalarm1       =   keepmin1;
      0002E4 85*23*13         [24] 1005 	mov	_minalarm1,_keepmin1
      0002E7 85*24*14         [24] 1006 	mov	(_minalarm1 + 1),(_keepmin1 + 1)
                                   1007 ;	main.c:208: secalarm2       =   keepsec2;
      0002EA 85*25*15         [24] 1008 	mov	_secalarm2,_keepsec2
      0002ED 85*26*16         [24] 1009 	mov	(_secalarm2 + 1),(_keepsec2 + 1)
                                   1010 ;	main.c:209: secalarm1       =   keepsec1;
      0002F0 85*27*17         [24] 1011 	mov	_secalarm1,_keepsec1
      0002F3 85*28*18         [24] 1012 	mov	(_secalarm1 + 1),(_keepsec1 + 1)
      0002F6                       1013 00102$:
                                   1014 ;	main.c:212: if(mode==1)  //Check if clock is in set clock mode
      0002F6 BE 01 06         [24] 1015 	cjne	r6,#0x01,00145$
      0002F9 BF 00 03         [24] 1016 	cjne	r7,#0x00,00145$
      0002FC EE               [12] 1017 	mov	a,r6
      0002FD 80 01            [24] 1018 	sjmp	00146$
      0002FF                       1019 00145$:
      0002FF E4               [12] 1020 	clr	a
      000300                       1021 00146$:
      000300 FD               [12] 1022 	mov	r5,a
      000301 60 40            [24] 1023 	jz	00116$
                                   1024 ;	main.c:214: IE              =   0x80;  //Disable Timer0 interrupt to stop the clock.
      000303 75 A8 80         [24] 1025 	mov	_IE,#0x80
                                   1026 ;	main.c:215: minalarm2       =   min2;
      000306 85*09*11         [24] 1027 	mov	_minalarm2,_min2
      000309 85*0A*12         [24] 1028 	mov	(_minalarm2 + 1),(_min2 + 1)
                                   1029 ;	main.c:216: minalarm1       =   min1;
      00030C 85*0B*13         [24] 1030 	mov	_minalarm1,_min1
      00030F 85*0C*14         [24] 1031 	mov	(_minalarm1 + 1),(_min1 + 1)
                                   1032 ;	main.c:217: secalarm2       =   sec2;
      000312 85*0D*15         [24] 1033 	mov	_secalarm2,_sec2
      000315 85*0E*16         [24] 1034 	mov	(_secalarm2 + 1),(_sec2 + 1)
                                   1035 ;	main.c:218: secalarm1       =   sec1;
      000318 85*0F*17         [24] 1036 	mov	_secalarm1,_sec1
      00031B 85*10*18         [24] 1037 	mov	(_secalarm1 + 1),(_sec1 + 1)
                                   1038 ;	main.c:219: sel_seg_to_incr =   1;
      00031E 75*00 01         [24] 1039 	mov	_sel_seg_to_incr,#0x01
      000321 75*01 00         [24] 1040 	mov	(_sel_seg_to_incr + 1),#0x00
                                   1041 ;	main.c:220: recnt_incr_seg  =   1;
      000324 75*04 01         [24] 1042 	mov	_recnt_incr_seg,#0x01
      000327 75*05 00         [24] 1043 	mov	(_recnt_incr_seg + 1),#0x00
                                   1044 ;	main.c:221: P2              =   dig_val[min2];
      00032A E5*09            [12] 1045 	mov	a,_min2
      00032C 24r2D            [12] 1046 	add	a,#_dig_val
      00032E F9               [12] 1047 	mov	r1,a
      00032F 87 A0            [24] 1048 	mov	_P2,@r1
                                   1049 ;	main.c:222: delay(100);
      000331 90 00 64         [24] 1050 	mov	dptr,#0x0064
      000334 C0 07            [24] 1051 	push	ar7
      000336 C0 06            [24] 1052 	push	ar6
      000338 C0 05            [24] 1053 	push	ar5
      00033A 12r00r00         [24] 1054 	lcall	_delay
      00033D D0 05            [24] 1055 	pop	ar5
      00033F D0 06            [24] 1056 	pop	ar6
      000341 D0 07            [24] 1057 	pop	ar7
                                   1058 ;	main.c:225: while(1)
      000343                       1059 00116$:
                                   1060 ;	main.c:227: if(start==0)  //Check if start pin is pressed
      000343 20 B3 5E         [24] 1061 	jb	_P3_3,00110$
                                   1062 ;	main.c:229: if(mode==0)
      000346 EE               [12] 1063 	mov	a,r6
      000347 4F               [12] 1064 	orl	a,r7
      000348 70 30            [24] 1065 	jnz	00106$
                                   1066 ;	main.c:231: keepmin2    =   minalarm2;
      00034A 85*11*21         [24] 1067 	mov	_keepmin2,_minalarm2
      00034D 85*12*22         [24] 1068 	mov	(_keepmin2 + 1),(_minalarm2 + 1)
                                   1069 ;	main.c:232: keepmin1    =   minalarm1;
      000350 85*13*23         [24] 1070 	mov	_keepmin1,_minalarm1
      000353 85*14*24         [24] 1071 	mov	(_keepmin1 + 1),(_minalarm1 + 1)
                                   1072 ;	main.c:233: keepsec2    =   secalarm2;
      000356 85*15*25         [24] 1073 	mov	_keepsec2,_secalarm2
      000359 85*16*26         [24] 1074 	mov	(_keepsec2 + 1),(_secalarm2 + 1)
                                   1075 ;	main.c:234: keepsec1    =   secalarm1;
      00035C 85*17*27         [24] 1076 	mov	_keepsec1,_secalarm1
      00035F 85*18*28         [24] 1077 	mov	(_keepsec1 + 1),(_secalarm1 + 1)
                                   1078 ;	main.c:235: alarmmin2   =   minalarm2;
      000362 85*11*19         [24] 1079 	mov	_alarmmin2,_minalarm2
      000365 85*12*1A         [24] 1080 	mov	(_alarmmin2 + 1),(_minalarm2 + 1)
                                   1081 ;	main.c:236: alarmmin1   =   minalarm1;
      000368 85*13*1B         [24] 1082 	mov	_alarmmin1,_minalarm1
      00036B 85*14*1C         [24] 1083 	mov	(_alarmmin1 + 1),(_minalarm1 + 1)
                                   1084 ;	main.c:237: alarmsec2   =   secalarm2;
      00036E 85*15*1D         [24] 1085 	mov	_alarmsec2,_secalarm2
      000371 85*16*1E         [24] 1086 	mov	(_alarmsec2 + 1),(_secalarm2 + 1)
                                   1087 ;	main.c:238: alarmsec1   =   secalarm1;
      000374 85*17*1F         [24] 1088 	mov	_alarmsec1,_secalarm1
      000377 85*18*20         [24] 1089 	mov	(_alarmsec1 + 1),(_secalarm1 + 1)
      00037A                       1090 00106$:
                                   1091 ;	main.c:241: if(mode==1)
      00037A ED               [12] 1092 	mov	a,r5
      00037B 60 18            [24] 1093 	jz	00108$
                                   1094 ;	main.c:243: min2    =   minalarm2;
      00037D 85*11*09         [24] 1095 	mov	_min2,_minalarm2
      000380 85*12*0A         [24] 1096 	mov	(_min2 + 1),(_minalarm2 + 1)
                                   1097 ;	main.c:244: min1    =   minalarm1;
      000383 85*13*0B         [24] 1098 	mov	_min1,_minalarm1
      000386 85*14*0C         [24] 1099 	mov	(_min1 + 1),(_minalarm1 + 1)
                                   1100 ;	main.c:245: sec2    =   secalarm2;
      000389 85*15*0D         [24] 1101 	mov	_sec2,_secalarm2
      00038C 85*16*0E         [24] 1102 	mov	(_sec2 + 1),(_secalarm2 + 1)
                                   1103 ;	main.c:246: sec1    =   secalarm1;
      00038F 85*17*0F         [24] 1104 	mov	_sec1,_secalarm1
      000392 85*18*10         [24] 1105 	mov	(_sec1 + 1),(_secalarm1 + 1)
      000395                       1106 00108$:
                                   1107 ;	main.c:249: TMOD    =   0x11;  //Reset the timer0
      000395 75 89 11         [24] 1108 	mov	_TMOD,#0x11
                                   1109 ;	main.c:250: TL0     =   0xf6;
      000398 75 8A F6         [24] 1110 	mov	_TL0,#0xf6
                                   1111 ;	main.c:251: TH0     =   0xFf;
      00039B 75 8C FF         [24] 1112 	mov	_TH0,#0xff
                                   1113 ;	main.c:252: IE      =   0x8A;  //Enabling Timer0 interrupt to start the display of clock
      00039E 75 A8 8A         [24] 1114 	mov	_IE,#0x8a
                                   1115 ;	main.c:253: TR0     =   1;
      0003A1 D2 8C            [12] 1116 	setb	_TR0
                                   1117 ;	main.c:254: break;
      0003A3 22               [24] 1118 	ret
      0003A4                       1119 00110$:
                                   1120 ;	main.c:257: if(set==0)  //Check if set pin is pressed
      0003A4 20 96 15         [24] 1121 	jb	_P1_6,00112$
                                   1122 ;	main.c:258: sel_seg_to_incr =   setfn();
      0003A7 C0 07            [24] 1123 	push	ar7
      0003A9 C0 06            [24] 1124 	push	ar6
      0003AB C0 05            [24] 1125 	push	ar5
      0003AD 12r00r33         [24] 1126 	lcall	_setfn
      0003B0 85 82*00         [24] 1127 	mov	_sel_seg_to_incr,dpl
      0003B3 85 83*01         [24] 1128 	mov	(_sel_seg_to_incr + 1),dph
      0003B6 D0 05            [24] 1129 	pop	ar5
      0003B8 D0 06            [24] 1130 	pop	ar6
      0003BA D0 07            [24] 1131 	pop	ar7
      0003BC                       1132 00112$:
                                   1133 ;	main.c:260: if(incr==0)  //Check if incr pin is pressed
      0003BC 20 97 84         [24] 1134 	jb	_P1_7,00116$
                                   1135 ;	main.c:261: increase(sel_seg_to_incr);
      0003BF 85*00 82         [24] 1136 	mov	dpl,_sel_seg_to_incr
      0003C2 85*01 83         [24] 1137 	mov	dph,(_sel_seg_to_incr + 1)
      0003C5 C0 07            [24] 1138 	push	ar7
      0003C7 C0 06            [24] 1139 	push	ar6
      0003C9 C0 05            [24] 1140 	push	ar5
      0003CB 12r01r0A         [24] 1141 	lcall	_increase
      0003CE D0 05            [24] 1142 	pop	ar5
      0003D0 D0 06            [24] 1143 	pop	ar6
      0003D2 D0 07            [24] 1144 	pop	ar7
      0003D4 02r03r43         [24] 1145 	ljmp	00116$
                                   1146 ;------------------------------------------------------------
                                   1147 ;Allocation info for local variables in function 'display'
                                   1148 ;------------------------------------------------------------
                                   1149 ;	main.c:265: void display(void) __interrupt (1)  // Function to display the digits on seven segment using the concept of seven segment multiplexing.
                                   1150 ;	-----------------------------------------
                                   1151 ;	 function display
                                   1152 ;	-----------------------------------------
      0003D7                       1153 _display:
      0003D7 C0 E0            [24] 1154 	push	acc
      0003D9 C0 F0            [24] 1155 	push	b
      0003DB C0 82            [24] 1156 	push	dpl
      0003DD C0 83            [24] 1157 	push	dph
      0003DF C0 01            [24] 1158 	push	ar1
      0003E1 C0 D0            [24] 1159 	push	psw
      0003E3 75 D0 00         [24] 1160 	mov	psw,#0x00
                                   1161 ;	main.c:267: TL0         =   0x36;  //Reload Timer0
      0003E6 75 8A 36         [24] 1162 	mov	_TL0,#0x36
                                   1163 ;	main.c:268: TH0         =   0xf6;
      0003E9 75 8C F6         [24] 1164 	mov	_TH0,#0xf6
                                   1165 ;	main.c:269: P2          =   0xFF;
      0003EC 75 A0 FF         [24] 1166 	mov	_P2,#0xff
                                   1167 ;	main.c:270: dig_ctrl_1  =   0;
      0003EF C2 93            [12] 1168 	clr	_P1_3
                                   1169 ;	main.c:271: dig_ctrl_3  =   0;
      0003F1 C2 91            [12] 1170 	clr	_P1_1
                                   1171 ;	main.c:272: dig_ctrl_2  =   0;
      0003F3 C2 92            [12] 1172 	clr	_P1_2
                                   1173 ;	main.c:273: dig_ctrl_4  =   0;
      0003F5 C2 90            [12] 1174 	clr	_P1_0
                                   1175 ;	main.c:275: dig_disp++;
      0003F7 05*08            [12] 1176 	inc	_dig_disp
                                   1177 ;	main.c:276: dig_disp=dig_disp%4;
      0003F9 53*08 03         [24] 1178 	anl	_dig_disp,#0x03
                                   1179 ;	main.c:278: switch(dig_disp)
      0003FC E5*08            [12] 1180 	mov	a,_dig_disp
      0003FE 24 FC            [12] 1181 	add	a,#0xff - 0x03
      000400 40 40            [24] 1182 	jc	00106$
      000402 E5*08            [12] 1183 	mov	a,_dig_disp
      000404 75 F0 03         [24] 1184 	mov	b,#0x03
      000407 A4               [48] 1185 	mul	ab
      000408 90r04r0C         [24] 1186 	mov	dptr,#00112$
      00040B 73               [24] 1187 	jmp	@a+dptr
      00040C                       1188 00112$:
      00040C 02r04r18         [24] 1189 	ljmp	00101$
      00040F 02r04r23         [24] 1190 	ljmp	00102$
      000412 02r04r2E         [24] 1191 	ljmp	00103$
      000415 02r04r39         [24] 1192 	ljmp	00104$
                                   1193 ;	main.c:280: case 0:
      000418                       1194 00101$:
                                   1195 ;	main.c:281: P2=dig_val[sec1];
      000418 E5*0F            [12] 1196 	mov	a,_sec1
      00041A 24r2D            [12] 1197 	add	a,#_dig_val
      00041C F9               [12] 1198 	mov	r1,a
      00041D 87 A0            [24] 1199 	mov	_P2,@r1
                                   1200 ;	main.c:282: dig_ctrl_1 = 1;
      00041F D2 93            [12] 1201 	setb	_P1_3
                                   1202 ;	main.c:283: break;
                                   1203 ;	main.c:285: case 1:
      000421 80 1F            [24] 1204 	sjmp	00106$
      000423                       1205 00102$:
                                   1206 ;	main.c:286: P2= dig_val[sec2];
      000423 E5*0D            [12] 1207 	mov	a,_sec2
      000425 24r2D            [12] 1208 	add	a,#_dig_val
      000427 F9               [12] 1209 	mov	r1,a
      000428 87 A0            [24] 1210 	mov	_P2,@r1
                                   1211 ;	main.c:287: dig_ctrl_2 = 1;
      00042A D2 92            [12] 1212 	setb	_P1_2
                                   1213 ;	main.c:288: break;
                                   1214 ;	main.c:290: case 2:
      00042C 80 14            [24] 1215 	sjmp	00106$
      00042E                       1216 00103$:
                                   1217 ;	main.c:291: P2= dig_val[min1];
      00042E E5*0B            [12] 1218 	mov	a,_min1
      000430 24r2D            [12] 1219 	add	a,#_dig_val
      000432 F9               [12] 1220 	mov	r1,a
      000433 87 A0            [24] 1221 	mov	_P2,@r1
                                   1222 ;	main.c:292: dig_ctrl_3 = 1;
      000435 D2 91            [12] 1223 	setb	_P1_1
                                   1224 ;	main.c:293: break;
                                   1225 ;	main.c:295: case 3:
      000437 80 09            [24] 1226 	sjmp	00106$
      000439                       1227 00104$:
                                   1228 ;	main.c:296: P2= dig_val[min2];
      000439 E5*09            [12] 1229 	mov	a,_min2
      00043B 24r2D            [12] 1230 	add	a,#_dig_val
      00043D F9               [12] 1231 	mov	r1,a
      00043E 87 A0            [24] 1232 	mov	_P2,@r1
                                   1233 ;	main.c:297: dig_ctrl_4 = 1;
      000440 D2 90            [12] 1234 	setb	_P1_0
                                   1235 ;	main.c:299: }
      000442                       1236 00106$:
      000442 D0 D0            [24] 1237 	pop	psw
      000444 D0 01            [24] 1238 	pop	ar1
      000446 D0 83            [24] 1239 	pop	dph
      000448 D0 82            [24] 1240 	pop	dpl
      00044A D0 F0            [24] 1241 	pop	b
      00044C D0 E0            [24] 1242 	pop	acc
      00044E 32               [24] 1243 	reti
                                   1244 ;	eliminated unneeded push/pop ar0
                                   1245 ;------------------------------------------------------------
                                   1246 ;Allocation info for local variables in function 'moveclock'
                                   1247 ;------------------------------------------------------------
                                   1248 ;	main.c:302: void moveclock(void) __interrupt 3  // Function to increment clock digits
                                   1249 ;	-----------------------------------------
                                   1250 ;	 function moveclock
                                   1251 ;	-----------------------------------------
      00044F                       1252 _moveclock:
      00044F C0 E0            [24] 1253 	push	acc
      000451 C0 D0            [24] 1254 	push	psw
                                   1255 ;	main.c:304: loop++;
      000453 05*29            [12] 1256 	inc	_loop
      000455 E4               [12] 1257 	clr	a
      000456 B5*29 02         [24] 1258 	cjne	a,_loop,00128$
      000459 05*2A            [12] 1259 	inc	(_loop + 1)
      00045B                       1260 00128$:
                                   1261 ;	main.c:305: if(loop==20)
      00045B 74 14            [12] 1262 	mov	a,#0x14
      00045D B5*29 06         [24] 1263 	cjne	a,_loop,00129$
      000460 E4               [12] 1264 	clr	a
      000461 B5*2A 02         [24] 1265 	cjne	a,(_loop + 1),00129$
      000464 80 03            [24] 1266 	sjmp	00130$
      000466                       1267 00129$:
      000466 02r04rEB         [24] 1268 	ljmp	00111$
      000469                       1269 00130$:
                                   1270 ;	main.c:307: sec1++;
      000469 05*0F            [12] 1271 	inc	_sec1
      00046B E4               [12] 1272 	clr	a
      00046C B5*0F 02         [24] 1273 	cjne	a,_sec1,00131$
      00046F 05*10            [12] 1274 	inc	(_sec1 + 1)
      000471                       1275 00131$:
                                   1276 ;	main.c:308: if(sec1==10)
      000471 74 0A            [12] 1277 	mov	a,#0x0a
      000473 B5*0F 06         [24] 1278 	cjne	a,_sec1,00132$
      000476 E4               [12] 1279 	clr	a
      000477 B5*10 02         [24] 1280 	cjne	a,(_sec1 + 1),00132$
      00047A 80 02            [24] 1281 	sjmp	00133$
      00047C                       1282 00132$:
      00047C 80 68            [24] 1283 	sjmp	00108$
      00047E                       1284 00133$:
                                   1285 ;	main.c:310: sec1=0;
      00047E E4               [12] 1286 	clr	a
      00047F F5*0F            [12] 1287 	mov	_sec1,a
      000481 F5*10            [12] 1288 	mov	(_sec1 + 1),a
                                   1289 ;	main.c:311: sec2++;
      000483 05*0D            [12] 1290 	inc	_sec2
                                   1291 ;	genFromRTrack removed	clr	a
      000485 B5*0D 02         [24] 1292 	cjne	a,_sec2,00134$
      000488 05*0E            [12] 1293 	inc	(_sec2 + 1)
      00048A                       1294 00134$:
                                   1295 ;	main.c:312: if(sec2==6)
      00048A 74 06            [12] 1296 	mov	a,#0x06
      00048C B5*0D 06         [24] 1297 	cjne	a,_sec2,00135$
      00048F E4               [12] 1298 	clr	a
      000490 B5*0E 02         [24] 1299 	cjne	a,(_sec2 + 1),00135$
      000493 80 02            [24] 1300 	sjmp	00136$
      000495                       1301 00135$:
      000495 80 4F            [24] 1302 	sjmp	00108$
      000497                       1303 00136$:
                                   1304 ;	main.c:314: sec1=0;
      000497 E4               [12] 1305 	clr	a
      000498 F5*0F            [12] 1306 	mov	_sec1,a
      00049A F5*10            [12] 1307 	mov	(_sec1 + 1),a
                                   1308 ;	main.c:315: sec2=0;
      00049C F5*0D            [12] 1309 	mov	_sec2,a
      00049E F5*0E            [12] 1310 	mov	(_sec2 + 1),a
                                   1311 ;	main.c:316: min1++;
      0004A0 05*0B            [12] 1312 	inc	_min1
                                   1313 ;	genFromRTrack removed	clr	a
      0004A2 B5*0B 02         [24] 1314 	cjne	a,_min1,00137$
      0004A5 05*0C            [12] 1315 	inc	(_min1 + 1)
      0004A7                       1316 00137$:
                                   1317 ;	main.c:317: if(min1==10)
      0004A7 74 0A            [12] 1318 	mov	a,#0x0a
      0004A9 B5*0B 06         [24] 1319 	cjne	a,_min1,00138$
      0004AC E4               [12] 1320 	clr	a
      0004AD B5*0C 02         [24] 1321 	cjne	a,(_min1 + 1),00138$
      0004B0 80 02            [24] 1322 	sjmp	00139$
      0004B2                       1323 00138$:
      0004B2 80 32            [24] 1324 	sjmp	00108$
      0004B4                       1325 00139$:
                                   1326 ;	main.c:319: sec1=0;
      0004B4 E4               [12] 1327 	clr	a
      0004B5 F5*0F            [12] 1328 	mov	_sec1,a
      0004B7 F5*10            [12] 1329 	mov	(_sec1 + 1),a
                                   1330 ;	main.c:320: sec2=0;
      0004B9 F5*0D            [12] 1331 	mov	_sec2,a
      0004BB F5*0E            [12] 1332 	mov	(_sec2 + 1),a
                                   1333 ;	main.c:321: min1=0;
      0004BD F5*0B            [12] 1334 	mov	_min1,a
      0004BF F5*0C            [12] 1335 	mov	(_min1 + 1),a
                                   1336 ;	main.c:322: min2++;
      0004C1 05*09            [12] 1337 	inc	_min2
                                   1338 ;	genFromRTrack removed	clr	a
      0004C3 B5*09 02         [24] 1339 	cjne	a,_min2,00140$
      0004C6 05*0A            [12] 1340 	inc	(_min2 + 1)
      0004C8                       1341 00140$:
                                   1342 ;	main.c:323: if(min2==6)
      0004C8 74 06            [12] 1343 	mov	a,#0x06
      0004CA B5*09 06         [24] 1344 	cjne	a,_min2,00141$
      0004CD E4               [12] 1345 	clr	a
      0004CE B5*0A 02         [24] 1346 	cjne	a,(_min2 + 1),00141$
      0004D1 80 02            [24] 1347 	sjmp	00142$
      0004D3                       1348 00141$:
      0004D3 80 11            [24] 1349 	sjmp	00108$
      0004D5                       1350 00142$:
                                   1351 ;	main.c:325: sec1=0;
      0004D5 E4               [12] 1352 	clr	a
      0004D6 F5*0F            [12] 1353 	mov	_sec1,a
      0004D8 F5*10            [12] 1354 	mov	(_sec1 + 1),a
                                   1355 ;	main.c:326: sec2=0;
      0004DA F5*0D            [12] 1356 	mov	_sec2,a
      0004DC F5*0E            [12] 1357 	mov	(_sec2 + 1),a
                                   1358 ;	main.c:327: min1=0;
      0004DE F5*0B            [12] 1359 	mov	_min1,a
      0004E0 F5*0C            [12] 1360 	mov	(_min1 + 1),a
                                   1361 ;	main.c:328: min2=0;
      0004E2 F5*09            [12] 1362 	mov	_min2,a
      0004E4 F5*0A            [12] 1363 	mov	(_min2 + 1),a
      0004E6                       1364 00108$:
                                   1365 ;	main.c:333: loop=0;
      0004E6 E4               [12] 1366 	clr	a
      0004E7 F5*29            [12] 1367 	mov	_loop,a
      0004E9 F5*2A            [12] 1368 	mov	(_loop + 1),a
      0004EB                       1369 00111$:
      0004EB D0 D0            [24] 1370 	pop	psw
      0004ED D0 E0            [24] 1371 	pop	acc
      0004EF 32               [24] 1372 	reti
                                   1373 ;	eliminated unneeded mov psw,# (no regs used in bank)
                                   1374 ;	eliminated unneeded push/pop dpl
                                   1375 ;	eliminated unneeded push/pop dph
                                   1376 ;	eliminated unneeded push/pop b
                                   1377 ;------------------------------------------------------------
                                   1378 ;Allocation info for local variables in function 'main'
                                   1379 ;------------------------------------------------------------
                                   1380 ;	main.c:337: void main()
                                   1381 ;	-----------------------------------------
                                   1382 ;	 function main
                                   1383 ;	-----------------------------------------
      0004F0                       1384 _main:
                                   1385 ;	main.c:339: mode        =   0;
      0004F0 E4               [12] 1386 	clr	a
      0004F1 F5*2B            [12] 1387 	mov	_mode,a
      0004F3 F5*2C            [12] 1388 	mov	(_mode + 1),a
                                   1389 ;	main.c:340: set         =   1;          //Initialize set, reset, start and incr pins as input
      0004F5 D2 96            [12] 1390 	setb	_P1_6
                                   1391 ;	main.c:341: resetalarm  =   1;
      0004F7 D2 95            [12] 1392 	setb	_P1_5
                                   1393 ;	main.c:342: resetclock  =   1;
      0004F9 D2 94            [12] 1394 	setb	_P1_4
                                   1395 ;	main.c:343: start       =   1;
      0004FB D2 B3            [12] 1396 	setb	_P3_3
                                   1397 ;	main.c:344: incr        =   1;
      0004FD D2 97            [12] 1398 	setb	_P1_7
                                   1399 ;	main.c:345: begin       =   0;
      0004FF E4               [12] 1400 	clr	a
      000500 F5*06            [12] 1401 	mov	_begin,a
      000502 F5*07            [12] 1402 	mov	(_begin + 1),a
                                   1403 ;	main.c:346: TMOD        =   0x11;       //Intialize Timer 0
      000504 75 89 11         [24] 1404 	mov	_TMOD,#0x11
                                   1405 ;	main.c:347: TL0         =   0xf6;       //Load timer0
      000507 75 8A F6         [24] 1406 	mov	_TL0,#0xf6
                                   1407 ;	main.c:348: TH0         =   0xFf;
      00050A 75 8C FF         [24] 1408 	mov	_TH0,#0xff
                                   1409 ;	main.c:349: IE          =   0x8A;       //Enable Timer0 interrupt
      00050D 75 A8 8A         [24] 1410 	mov	_IE,#0x8a
                                   1411 ;	main.c:350: TR0         =   1;          //Start Timer0
      000510 D2 8C            [12] 1412 	setb	_TR0
                                   1413 ;	main.c:351: TL1         =   0xFD;
      000512 75 8B FD         [24] 1414 	mov	_TL1,#0xfd
                                   1415 ;	main.c:352: TH1         =   0x4B;
      000515 75 8D 4B         [24] 1416 	mov	_TH1,#0x4b
                                   1417 ;	main.c:353: TR1         =   1;          // Start Timer1
      000518 D2 8E            [12] 1418 	setb	_TR1
                                   1419 ;	main.c:355: while(1)
      00051A                       1420 00112$:
                                   1421 ;	main.c:357: if(resetalarm==0)     //Check if reset alarm pin is pressed
      00051A 20 95 06         [24] 1422 	jb	_P1_5,00102$
                                   1423 ;	main.c:359: resetfn(0);
      00051D 90 00 00         [24] 1424 	mov	dptr,#0x0000
      000520 12r02rA5         [24] 1425 	lcall	_resetfn
      000523                       1426 00102$:
                                   1427 ;	main.c:361: if(resetclock==0)     //Check if reset clock pin is pressed
      000523 20 94 06         [24] 1428 	jb	_P1_4,00104$
                                   1429 ;	main.c:363: resetfn(1);
      000526 90 00 01         [24] 1430 	mov	dptr,#0x0001
      000529 12r02rA5         [24] 1431 	lcall	_resetfn
      00052C                       1432 00104$:
                                   1433 ;	main.c:365: if(min2==alarmmin2&&min1==alarmmin1&&sec2==alarmsec2&&sec1==alarmsec1&&begin==1)  // Check for Alarm condition
      00052C E5*19            [12] 1434 	mov	a,_alarmmin2
      00052E B5*09 E9         [24] 1435 	cjne	a,_min2,00112$
      000531 E5*1A            [12] 1436 	mov	a,(_alarmmin2 + 1)
      000533 B5*0A E4         [24] 1437 	cjne	a,(_min2 + 1),00112$
      000536 E5*1B            [12] 1438 	mov	a,_alarmmin1
      000538 B5*0B DF         [24] 1439 	cjne	a,_min1,00112$
      00053B E5*1C            [12] 1440 	mov	a,(_alarmmin1 + 1)
      00053D B5*0C DA         [24] 1441 	cjne	a,(_min1 + 1),00112$
      000540 E5*1D            [12] 1442 	mov	a,_alarmsec2
      000542 B5*0D D5         [24] 1443 	cjne	a,_sec2,00112$
      000545 E5*1E            [12] 1444 	mov	a,(_alarmsec2 + 1)
      000547 B5*0E D0         [24] 1445 	cjne	a,(_sec2 + 1),00112$
      00054A E5*1F            [12] 1446 	mov	a,_alarmsec1
      00054C B5*0F CB         [24] 1447 	cjne	a,_sec1,00112$
      00054F E5*20            [12] 1448 	mov	a,(_alarmsec1 + 1)
      000551 B5*10 C6         [24] 1449 	cjne	a,(_sec1 + 1),00112$
      000554 74 01            [12] 1450 	mov	a,#0x01
      000556 B5*06 06         [24] 1451 	cjne	a,_begin,00150$
      000559 14               [12] 1452 	dec	a
      00055A B5*07 02         [24] 1453 	cjne	a,(_begin + 1),00150$
      00055D 80 02            [24] 1454 	sjmp	00151$
      00055F                       1455 00150$:
      00055F 80 B9            [24] 1456 	sjmp	00112$
      000561                       1457 00151$:
                                   1458 ;	main.c:367: buzzer=0;
      000561 C2 B7            [12] 1459 	clr	_P3_7
                                   1460 ;	main.c:368: delay(500);
      000563 90 01 F4         [24] 1461 	mov	dptr,#0x01f4
      000566 12r00r00         [24] 1462 	lcall	_delay
                                   1463 ;	main.c:369: buzzer=1;
      000569 D2 B7            [12] 1464 	setb	_P3_7
      00056B 80 AD            [24] 1465 	sjmp	00112$
                                   1466 	.area CSEG    (CODE)
                                   1467 	.area CONST   (CODE)
                                   1468 	.area XINIT   (CODE)
                                   1469 	.area CABS    (ABS,CODE)
